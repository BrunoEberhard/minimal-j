== Self references

Classes that contain direct or indirect references to objects of the class itself can cause
some problems:
* At serialization possible cycles must be handled.
* Same on persistence level. Imagine an object with a not nullable reference to itself. This is quite a problem if the id of the object should be generated by the database.
* Even without cycles if you read the root of a quite large data tree possible the whole tree is loaded from the database.

For these reasons Minimal-J doesn't allow direct self references. It's not allowed to have
this entity class:

[source,java,title"Invalid tree class"]
----
public class InvalidNode {
	public Object id;
	public InvalidNode left, right;
}
----

Also indirect references are not allowed:

[source,java,title"Invalid cycle reference classes"]
----
public class InvalidA {
	public Object id;
	public InvalidB reference;
}

public class InvalidB {
	public Object id;
	public InvalidA reference;
}
----

=== Self references through views

But sometimes it's quite useful to build a tree of entities. Minimal-J provides a loop hole for this
situations. It's allowed to reference itself if the reference is a View:

[source,java,title"Valid tree class"]
----
public class Node {
	public Object id;
	public NodeView left, right;
}

public class NodeView implements View<Node> {
	public Object id;
}
----

If you want to access 'left' you have to do a special read to convert the NodeView to a
Node:

[source,java,title"Read tree nodes"]
----
	Node node = Backend.read(Node.class, id);
	Node left = node.left != null ? Backend.read(Node.class, node.left.id) : null;
----

or the same with a helper method:

[source,java,title"Use of ViewUtils"]
----
	Node node = Backend.read(Node.class, id);
	Node left = ViewUtils.viewed(node.left);
----


In this way you can build trees in your models. Minimal-J just prevents that you accidentally read
more objects than you really wanted. You have to read them explicit and are aware of what is happening.

=== Self references through lists

Because lists are always lazy loaded there is no problem of having self references through a List.
The following class is perfectly valid:

[source,java,title"Valid tree class"]
----
public class Node {
	public Object id;
	public List<Node> children;
}
----

Of course a serialization method has to take care of self references in this case. But that's not
so much trouble to implement.