== Frontend details

=== Pages

Pages are one of the building blocks of an application. On small device they fill up the whole
display space. On a large display a main page can be accompanied by some depending detail
pages.

image::page_with_detail_large_device.png[title="Page with detail page on large device"]

image::page_with_detail_small_device.png[title="Page with detail page on small device"]

Most frontends provide back and forward buttons to navigate between pages.

Pages provide a title, content and sometimes actions. The content should be static.
This means the user cannot make any input on a page. Inputs should be done in a dialog.

=== Contents

IContent is the interface used for contents of Pages or Dialogs.

[source,java,title="Page.java"]
----
public abstract class Page {
	
	public abstract IContent getContent();
	
	[..]
}
----

IContent is a marker interface with no methods at all. You normally don't implement your own
content classes but use one of the three possible contents for pages: tables (list of entities),
forms (details of an entity) or html (texts, reports).

Note that IContent doesn't extend IComponent. In contrast to other UI frameworks you cannot
nest components. It's not possible to put a table in a FormElement.

==== Table

Tables show a list of entities of the same class. Minimal-J doesn't support inheritence for business classes so the objects
will be really of the same class. Tables are meant to be read only. The displayed objects cannot be edited directly in the table.
But tables can have a context menu with actions. And a row of table can be double clicked (or 'started' in the way the frontend
should do it according where it lives).

Table columns have all the same width. If this hurts too much it is possible to merge to fields of the business object in one column.

===== TablePage

To display a table you can extend from TablePage. TablePage needs the keys for the columns.
The keys are the $ constants from the entity. And you have to implement the load() method to define what are the entities
the table should contain.

===== TablePageWithDetail

There is the common pattern that from a list of entities one is selected and from the one the details should be displayed.
This is sometimes called master/detail pattern.

[source,java,title="TablePageWithDetail.java"]
----
public abstract class TablePageWithDetail<T, DETAIL_PAGE extends Page> extends TablePage<T> {

	public TablePageWithDetail(Object[] keys) {
		super(keys);
	}

	protected abstract List<T> load();

	protected abstract DETAIL_PAGE createDetailPage(T mainObject);

	protected abstract DETAIL_PAGE updateDetailPage(DETAIL_PAGE page, T mainObject);
	
	[..]	
}
----

As this pattern can have different specialities there are some aspects to know about the TablePageWithDetail class.

Even if all the objects in the table must be of the same class the Pages used to display their details can vary.
The method createDetailPage() should construct a page that can be used to display the details of the object 'mainObject'.

Now if the user selects an other entity the method updateDetailPage() method. This method can decide if the already
existing page can be reused with new values or of a completly new Page should be constructed. In other words the
method can return the page it gets as input argument or go the more expensive way and throw away the existing page.

===== SimpleTablePageWithDetail

If TablePageWithDetail is too complicated for your needs maybe SimpleTablePageWithDetail is what fits. If it's for sure
that the same detail page can be used for every entity in the table then the updateDetailPage() method is not needed.
SimpleTablePageWithDetail provides a default implementation for that method.

==== Html

With html content you can break out from the constraints given by Minimal-J. A HtmlPage can display basically every URL or html
string. The frontends may depend on system funcionality for that. For example the SwingFrontend uses the JavaFX bridge to the system
browser. And for the web based frontend displaying web content is the easiest part.

Displaying html is meant to be used for start or help pages. Also report engines (not in scope for Minimal-J) could present their
reports. Of course the html pages could contain links and even input forms. But this is _not_ the way to extend the functionality
of Minimal-J or to circumvent its rules.

==== Form

Forms in Minimal-J have basically the same funtion as in HTML.
You define with a Form what fields of an entity are shown and in which order.
Fields can depend on each other. This could mean if a checkbox is selected some fields get editable.

There are no things like 'LayoutManagers'. Of course the order in which you add the fields define somehow
the later layout of the form. But you cannot set horizontal weights to a field. This makes all forms look very regular.

===== FormElement

FormElement objects represent the business side. Fields of an entity are 'bound' to a FormElement.
Minimal-J doesn't emphasize much on binding.

It's very important to note that a FormElement is _not_ a IComponent but _provides_ one. This
is necessary as the specifc implementations of the components depend on the chosen Frontend.

The framework provides the basic form elements like the ones for formatted strings, dates, numbers and enumerations. But
for more complex types you will define your one FormElement classes. Look at the existing examples how to do this!

===== Inputs / Components

Minimal-J doesn't try to have as many shiny components as possible. Where other frameworks are proud to present pages of predefined components
Minimal-J restricts you basically to texts, comboboxes and checkboxes (with some veriations).

The Frontend class acts a factory for all components. This makes sense as for differend frontends (web or rich client) different components have
to be created.
